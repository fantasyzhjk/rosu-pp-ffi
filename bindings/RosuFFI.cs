// Automatically generated by Interoptopus.

#pragma warning disable 0105
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using RosuPP;
#pragma warning restore 0105

namespace RosuPP
{
    public static partial class RosuLibrary
    {
        public const string NativeLib = "rosu_pp_ffi";

        static RosuLibrary()
        {
        }


        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_destroy")]
        public static extern FFIError beatmap_attributes_destroy(ref IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        public static void beatmap_attributes_destroy_checked(ref IntPtr context)
        {
            var rval = beatmap_attributes_destroy(ref context);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_new")]
        public static extern FFIError beatmap_attributes_new(ref IntPtr context);

        public static void beatmap_attributes_new_checked(ref IntPtr context)
        {
            var rval = beatmap_attributes_new(ref context);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_mode")]
        public static extern void beatmap_attributes_mode(IntPtr context, Mode mode);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_p_mods")]
        public static extern void beatmap_attributes_p_mods(IntPtr context, IntPtr mods);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_i_mods")]
        public static extern void beatmap_attributes_i_mods(IntPtr context, uint mods);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_s_mods")]
        public static extern FFIError beatmap_attributes_s_mods(IntPtr context, string str);

        public static void beatmap_attributes_s_mods_checked(IntPtr context, string str)
        {
            var rval = beatmap_attributes_s_mods(context, str);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_clock_rate")]
        public static extern void beatmap_attributes_clock_rate(IntPtr context, double clock_rate);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_ar")]
        public static extern void beatmap_attributes_ar(IntPtr context, float ar);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_cs")]
        public static extern void beatmap_attributes_cs(IntPtr context, float cs);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_hp")]
        public static extern void beatmap_attributes_hp(IntPtr context, float hp);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_od")]
        public static extern void beatmap_attributes_od(IntPtr context, float od);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_get_clock_rate")]
        public static extern double beatmap_attributes_get_clock_rate(IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_attributes_build")]
        public static extern BeatmapAttributes beatmap_attributes_build(IntPtr context, IntPtr beatmap);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_destroy")]
        public static extern FFIError beatmap_destroy(ref IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        public static void beatmap_destroy_checked(ref IntPtr context)
        {
            var rval = beatmap_destroy(ref context);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_from_bytes")]
        public static extern FFIError beatmap_from_bytes(ref IntPtr context, Sliceu8 data);

        public static void beatmap_from_bytes(ref IntPtr context, byte[] data)
        {
            unsafe
            {
                fixed (void* ptr_data = data)
                {
                    var data_slice = new Sliceu8(new IntPtr(ptr_data), (ulong) data.Length);
                    var rval = beatmap_from_bytes(ref context, data_slice);;
                    if (rval != FFIError.Ok)
                    {
                        throw new InteropException<FFIError>(rval);
                    }
                }
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_from_path")]
        public static extern FFIError beatmap_from_path(ref IntPtr context, string path);

        public static void beatmap_from_path_checked(ref IntPtr context, string path)
        {
            var rval = beatmap_from_path(ref context, path);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        /// Convert a Beatmap to the specified mode
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_convert")]
        public static extern Bool beatmap_convert(IntPtr context, Mode mode, IntPtr mods);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_bpm")]
        public static extern double beatmap_bpm(IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_total_break_time")]
        public static extern double beatmap_total_break_time(IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_mode")]
        public static extern Mode beatmap_mode(IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "beatmap_is_convert")]
        public static extern Bool beatmap_is_convert(IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_destroy")]
        public static extern FFIError difficulty_destroy(ref IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        public static void difficulty_destroy_checked(ref IntPtr context)
        {
            var rval = difficulty_destroy(ref context);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_new")]
        public static extern FFIError difficulty_new(ref IntPtr context);

        public static void difficulty_new_checked(ref IntPtr context)
        {
            var rval = difficulty_new(ref context);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_p_mods")]
        public static extern void difficulty_p_mods(IntPtr context, IntPtr mods);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_i_mods")]
        public static extern void difficulty_i_mods(IntPtr context, uint mods);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_s_mods")]
        public static extern FFIError difficulty_s_mods(IntPtr context, string str);

        public static void difficulty_s_mods_checked(IntPtr context, string str)
        {
            var rval = difficulty_s_mods(context, str);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_passed_objects")]
        public static extern void difficulty_passed_objects(IntPtr context, uint passed_objects);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_clock_rate")]
        public static extern void difficulty_clock_rate(IntPtr context, double clock_rate);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_ar")]
        public static extern void difficulty_ar(IntPtr context, float ar);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_cs")]
        public static extern void difficulty_cs(IntPtr context, float cs);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_hp")]
        public static extern void difficulty_hp(IntPtr context, float hp);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_od")]
        public static extern void difficulty_od(IntPtr context, float od);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_hardrock_offsets")]
        public static extern void difficulty_hardrock_offsets(IntPtr context, Bool hardrock_offsets);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_lazer")]
        public static extern void difficulty_lazer(IntPtr context, Bool lazer);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_calculate")]
        public static extern DifficultyAttributes difficulty_calculate(IntPtr context, IntPtr beatmap);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "difficulty_get_clock_rate")]
        public static extern double difficulty_get_clock_rate(IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_destroy")]
        public static extern FFIError performance_destroy(ref IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        public static void performance_destroy_checked(ref IntPtr context)
        {
            var rval = performance_destroy(ref context);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_new")]
        public static extern FFIError performance_new(ref IntPtr context);

        public static void performance_new_checked(ref IntPtr context)
        {
            var rval = performance_new(ref context);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_mode")]
        public static extern void performance_mode(IntPtr context, Mode mode);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_p_mods")]
        public static extern void performance_p_mods(IntPtr context, IntPtr mods);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_i_mods")]
        public static extern void performance_i_mods(IntPtr context, uint mods);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_s_mods")]
        public static extern FFIError performance_s_mods(IntPtr context, string str);

        public static void performance_s_mods_checked(IntPtr context, string str)
        {
            var rval = performance_s_mods(context, str);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_passed_objects")]
        public static extern void performance_passed_objects(IntPtr context, uint passed_objects);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_clock_rate")]
        public static extern void performance_clock_rate(IntPtr context, double clock_rate);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_ar")]
        public static extern void performance_ar(IntPtr context, float ar);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_cs")]
        public static extern void performance_cs(IntPtr context, float cs);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_hp")]
        public static extern void performance_hp(IntPtr context, float hp);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_od")]
        public static extern void performance_od(IntPtr context, float od);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_hardrock_offsets")]
        public static extern void performance_hardrock_offsets(IntPtr context, Bool hardrock_offsets);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_state")]
        public static extern void performance_state(IntPtr context, ScoreState state);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_accuracy")]
        public static extern void performance_accuracy(IntPtr context, double accuracy);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_misses")]
        public static extern void performance_misses(IntPtr context, uint misses);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_combo")]
        public static extern void performance_combo(IntPtr context, uint combo);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_hitresult_priority")]
        public static extern void performance_hitresult_priority(IntPtr context, HitResultPriority hitresult_priority);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_lazer")]
        public static extern void performance_lazer(IntPtr context, Bool lazer);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_large_tick_hits")]
        public static extern void performance_large_tick_hits(IntPtr context, uint large_tick_hits);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_small_tick_hits")]
        public static extern void performance_small_tick_hits(IntPtr context, uint small_tick_hits);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_slider_end_hits")]
        public static extern void performance_slider_end_hits(IntPtr context, uint slider_end_hits);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_n300")]
        public static extern void performance_n300(IntPtr context, uint n300);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_n100")]
        public static extern void performance_n100(IntPtr context, uint n100);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_n50")]
        public static extern void performance_n50(IntPtr context, uint n50);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_n_katu")]
        public static extern void performance_n_katu(IntPtr context, uint n_katu);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_n_geki")]
        public static extern void performance_n_geki(IntPtr context, uint n_geki);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_generate_state")]
        public static extern ScoreState performance_generate_state(IntPtr context, IntPtr beatmap);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_generate_state_from_difficulty")]
        public static extern ScoreState performance_generate_state_from_difficulty(IntPtr context, DifficultyAttributes difficulty_attr);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_calculate")]
        public static extern PerformanceAttributes performance_calculate(IntPtr context, IntPtr beatmap);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_calculate_from_difficulty")]
        public static extern PerformanceAttributes performance_calculate_from_difficulty(IntPtr context, DifficultyAttributes difficulty_attr);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "performance_get_clock_rate")]
        public static extern double performance_get_clock_rate(IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "string_destroy")]
        public static extern FFIError string_destroy(ref IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        public static void string_destroy_checked(ref IntPtr context)
        {
            var rval = string_destroy(ref context);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "string_from_c_str")]
        public static extern FFIError string_from_c_str(ref IntPtr context, string str);

        public static void string_from_c_str_checked(ref IntPtr context, string str)
        {
            var rval = string_from_c_str(ref context, str);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "string_empty")]
        public static extern FFIError string_empty(ref IntPtr context);

        public static void string_empty_checked(ref IntPtr context)
        {
            var rval = string_empty(ref context);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "string_is_init")]
        public static extern Bool string_is_init(IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "string_to_cstr")]
        public static extern IntPtr string_to_cstr(IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_destroy")]
        public static extern FFIError mods_destroy(ref IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        public static void mods_destroy_checked(ref IntPtr context)
        {
            var rval = mods_destroy(ref context);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_new")]
        public static extern FFIError mods_new(ref IntPtr context, Mode mode);

        public static void mods_new_checked(ref IntPtr context, Mode mode)
        {
            var rval = mods_new(ref context, mode);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_from_acronyms")]
        public static extern FFIError mods_from_acronyms(ref IntPtr context, string str, Mode mode);

        public static void mods_from_acronyms_checked(ref IntPtr context, string str, Mode mode)
        {
            var rval = mods_from_acronyms(ref context, str, mode);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_from_bits")]
        public static extern FFIError mods_from_bits(ref IntPtr context, uint bits, Mode mode);

        public static void mods_from_bits_checked(ref IntPtr context, uint bits, Mode mode)
        {
            var rval = mods_from_bits(ref context, bits, mode);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_from_json")]
        public static extern FFIError mods_from_json(ref IntPtr context, string str, Mode mode);

        public static void mods_from_json_checked(ref IntPtr context, string str, Mode mode)
        {
            var rval = mods_from_json(ref context, str, mode);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_from_json_sanitize")]
        public static extern FFIError mods_from_json_sanitize(ref IntPtr context, string str, Mode mode);

        public static void mods_from_json_sanitize_checked(ref IntPtr context, string str, Mode mode)
        {
            var rval = mods_from_json_sanitize(ref context, str, mode);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_remove_incompatible_mods")]
        public static extern void mods_remove_incompatible_mods(IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_bits")]
        public static extern uint mods_bits(IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_len")]
        public static extern uint mods_len(IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_json")]
        public static extern void mods_json(IntPtr context, IntPtr str);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_insert_json")]
        public static extern Bool mods_insert_json(IntPtr context, string str);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_insert")]
        public static extern Bool mods_insert(IntPtr context, string str);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_contains")]
        public static extern Bool mods_contains(IntPtr context, string str);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_clear")]
        public static extern void mods_clear(IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "mods_clock_rate")]
        public static extern Optionf64 mods_clock_rate(IntPtr context);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "debug_difficylty_attributes")]
        public static extern void debug_difficylty_attributes(ref DifficultyAttributes res, IntPtr str);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "debug_performance_attributes")]
        public static extern void debug_performance_attributes(ref PerformanceAttributes res, IntPtr str);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "debug_score_state")]
        public static extern void debug_score_state(ref ScoreState res, IntPtr str);

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "calculate_accuacy")]
        public static extern double calculate_accuacy(ref ScoreState state, ref DifficultyAttributes difficulty, OsuScoreOrigin origin);

    }

    public enum HitResultPriority
    {
        BestCase = 0,
        WorstCase = 1,
    }

    public enum Mode
    {
        /// osu!standard
        Osu = 0,
        /// osu!taiko
        Taiko = 1,
        /// osu!catch
        Catch = 2,
        /// osu!mania
        Mania = 3,
    }

    /// Type to pass [`OsuScoreState::accuracy`] and specify the origin of a score.
    public enum OsuScoreOrigin
    {
        /// For scores set on osu!stable
        Stable = 0,
        /// For scores set on osu!lazer with slider accuracy
        WithSliderAcc = 1,
        /// For scores set on osu!lazer without slider accuracy
        WithoutSliderAcc = 2,
    }

    /// Summary struct for a [`Beatmap`]'s attributes.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct BeatmapAttributes
    {
        /// The approach rate.
        public double ar;
        /// The overall difficulty.
        public double od;
        /// The circle size.
        public double cs;
        /// The health drain rate
        public double hp;
        /// The clock rate with respect to mods.
        public double clock_rate;
        /// The hit windows for approach rate and overall difficulty.
        public HitWindows hit_windows;
    }

    /// The result of a difficulty calculation on an osu!catch map.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct CatchDifficultyAttributes
    {
        /// The final star rating
        public double stars;
        /// The approach rate.
        public double ar;
        /// The amount of fruits.
        public uint n_fruits;
        /// The amount of droplets.
        public uint n_droplets;
        /// The amount of tiny droplets.
        public uint n_tiny_droplets;
        /// Whether the [`Beatmap`] was a convert i.e. an osu!standard map.
        ///
        /// [`Beatmap`]: crate::model::beatmap::Beatmap
        public Bool is_convert;
    }

    /// The result of a performance calculation on an osu!catch map.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct CatchPerformanceAttributes
    {
        /// The difficulty attributes that were used for the performance calculation
        public CatchDifficultyAttributes difficulty;
        /// The final performance points.
        public double pp;
    }

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct DifficultyAttributes
    {
        public OptionOsuDifficultyAttributes osu;
        public OptionTaikoDifficultyAttributes taiko;
        public OptionCatchDifficultyAttributes fruit;
        public OptionManiaDifficultyAttributes mania;
        public Mode mode;
    }

    /// AR and OD hit windows
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct HitWindows
    {
        /// Hit window for approach rate i.e. `TimePreempt` in milliseconds.
        public double ar;
        /// Hit window for overall difficulty i.e. time to hit a 300 ("Great") in milliseconds.
        public double od_great;
        /// Hit window for overall difficulty i.e. time to hit a 100 ("Ok") in milliseconds.
        ///
        /// `None` for osu!mania.
        public Optionf64 od_ok;
    }

    /// The result of a difficulty calculation on an osu!mania map.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct ManiaDifficultyAttributes
    {
        /// The final star rating.
        public double stars;
        /// The perceived hit window for an n300 inclusive of rate-adjusting mods (DT/HT/etc).
        public double hit_window;
        /// The amount of hitobjects in the map.
        public uint n_objects;
        /// The amount of hold notes in the map.
        public uint n_hold_notes;
        /// The maximum achievable combo.
        public uint max_combo;
        /// Whether the [`Beatmap`] was a convert i.e. an osu!standard map.
        ///
        /// [`Beatmap`]: crate::model::beatmap::Beatmap
        public Bool is_convert;
    }

    /// The result of a performance calculation on an osu!mania map.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct ManiaPerformanceAttributes
    {
        /// The difficulty attributes that were used for the performance calculation.
        public ManiaDifficultyAttributes difficulty;
        /// The final performance points.
        public double pp;
        /// The difficulty portion of the final pp.
        public double pp_difficulty;
    }

    /// The result of a difficulty calculation on an osu!standard map.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct OsuDifficultyAttributes
    {
        /// The difficulty of the aim skill.
        public double aim;
        /// The difficulty of the speed skill.
        public double speed;
        /// The difficulty of the flashlight skill.
        public double flashlight;
        /// The ratio of the aim strain with and without considering sliders
        public double slider_factor;
        /// The number of clickable objects weighted by difficulty.
        public double speed_note_count;
        /// Weighted sum of aim strains.
        public double aim_difficult_strain_count;
        /// Weighted sum of speed strains.
        public double speed_difficult_strain_count;
        /// The approach rate.
        public double ar;
        /// The overall difficulty
        public double od;
        /// The health drain rate.
        public double hp;
        /// The amount of circles.
        public uint n_circles;
        /// The amount of sliders.
        public uint n_sliders;
        /// The amount of "large ticks".
        ///
        /// The meaning depends on the kind of score:
        /// - if set on osu!stable, this value is irrelevant
        /// - if set on osu!lazer *without* `CL`, this value is the amount of
        ///   slider ticks and repeats
        /// - if set on osu!lazer *with* `CL`, this value is the amount of slider
        ///   heads, ticks, and repeats
        public uint n_large_ticks;
        /// The amount of spinners.
        public uint n_spinners;
        /// The final star rating
        public double stars;
        /// The maximum combo.
        public uint max_combo;
    }

    /// The result of a performance calculation on an osu!standard map.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct OsuPerformanceAttributes
    {
        /// The difficulty attributes that were used for the performance calculation
        public OsuDifficultyAttributes difficulty;
        /// The final performance points.
        public double pp;
        /// The accuracy portion of the final pp.
        public double pp_acc;
        /// The aim portion of the final pp.
        public double pp_aim;
        /// The flashlight portion of the final pp.
        public double pp_flashlight;
        /// The speed portion of the final pp.
        public double pp_speed;
        /// Misses including an approximated amount of slider breaks
        public double effective_miss_count;
    }

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct PerformanceAttributes
    {
        public OptionOsuPerformanceAttributes osu;
        public OptionTaikoPerformanceAttributes taiko;
        public OptionCatchPerformanceAttributes fruit;
        public OptionManiaPerformanceAttributes mania;
        public Mode mode;
    }

    /// Aggregation for a score's current state.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct ScoreState
    {
        /// Maximum combo that the score has had so far. **Not** the maximum
        /// possible combo of the map so far.
        ///
        /// Note that for osu!catch only fruits and droplets are considered for
        /// combo.
        ///
        /// Irrelevant for osu!mania.
        public uint max_combo;
        /// "Large tick" hits for osu!standard.
        ///
        /// The meaning depends on the kind of score:
        /// - if set on osu!stable, this field is irrelevant and can be `0`
        /// - if set on osu!lazer *without* `CL`, this field is the amount of hit
        ///   slider ticks and repeats
        /// - if set on osu!lazer *with* `CL`, this field is the amount of hit
        ///   slider heads, ticks, and repeats
        ///
        /// Only relevant for osu!lazer.
        public uint osu_large_tick_hits;
        /// "Small ticks" hits for osu!standard.
        ///
        /// These are essentially the slider end hits for lazer scores without
        /// slider accuracy.
        ///
        /// Only relevant for osu!lazer.
        public uint osu_small_tick_hits;
        /// Amount of successfully hit slider ends.
        ///
        /// Only relevant for osu!standard in lazer.
        public uint slider_end_hits;
        /// Amount of current gekis (n320 for osu!mania).
        public uint n_geki;
        /// Amount of current katus (tiny droplet misses for osu!catch / n200 for
        /// osu!mania).
        public uint n_katu;
        /// Amount of current 300s (fruits for osu!catch).
        public uint n300;
        /// Amount of current 100s (droplets for osu!catch).
        public uint n100;
        /// Amount of current 50s (tiny droplets for osu!catch).
        public uint n50;
        /// Amount of current misses (fruits + droplets for osu!catch).
        public uint misses;
    }

    /// The result of a difficulty calculation on an osu!taiko map.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct TaikoDifficultyAttributes
    {
        /// The difficulty of the stamina skill.
        public double stamina;
        /// The difficulty of the rhythm skill.
        public double rhythm;
        /// The difficulty of the color skill.
        public double color;
        /// The difficulty of the hardest parts of the map.
        public double peak;
        /// The perceived hit window for an n300 inclusive of rate-adjusting mods (DT/HT/etc)
        public double great_hit_window;
        /// The perceived hit window for an n100 inclusive of rate-adjusting mods (DT/HT/etc)
        public double ok_hit_window;
        /// The ratio of stamina difficulty from mono-color (single color) streams to total
        /// stamina difficulty.
        public double mono_stamina_factor;
        /// The final star rating.
        public double stars;
        /// The maximum combo.
        public uint max_combo;
        /// Whether the [`Beatmap`] was a convert i.e. an osu!standard map.
        ///
        /// [`Beatmap`]: crate::model::beatmap::Beatmap
        public Bool is_convert;
    }

    /// The result of a performance calculation on an osu!taiko map.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct TaikoPerformanceAttributes
    {
        /// The difficulty attributes that were used for the performance calculation
        public TaikoDifficultyAttributes difficulty;
        /// The final performance points.
        public double pp;
        /// The accuracy portion of the final pp.
        public double pp_acc;
        /// The strain portion of the final pp.
        public double pp_difficulty;
        /// Scaled miss count based on total hits.
        public double effective_miss_count;
        /// Upper bound on the player's tap deviation.
        public Optionf64 estimated_unstable_rate;
    }

    public enum FFIError
    {
        Ok = 0,
        Null = 100,
        Panic = 200,
        IoError = 300,
        Utf8Error = 400,
        InvalidString = 500,
        SerializeError = 600,
        Unknown = 1000,
    }

    ///A pointer to an array of data someone else owns which may not be modified.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Sliceu8
    {
        ///Pointer to start of immutable data.
        IntPtr data;
        ///Number of elements.
        ulong len;
    }

    public partial struct Sliceu8 : IEnumerable<byte>
    {
        public Sliceu8(GCHandle handle, ulong count)
        {
            this.data = handle.AddrOfPinnedObject();
            this.len = count;
        }
        public Sliceu8(IntPtr handle, ulong count)
        {
            this.data = handle;
            this.len = count;
        }
        #if (NETSTANDARD2_1_OR_GREATER || NET5_0_OR_GREATER || NETCOREAPP2_1_OR_GREATER)
        public ReadOnlySpan<byte> ReadOnlySpan
        {
            get
            {
                unsafe
                {
                    return new ReadOnlySpan<byte>(this.data.ToPointer(), (int) this.len);
                }
            }
        }
        #endif
        public byte this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                unsafe
                {
                    var d = (byte*) data.ToPointer();
                    return d[i];
                }
            }
        }
        public byte[] Copied
        {
            get
            {
                var rval = new byte[len];
                unsafe
                {
                    fixed (void* dst = rval)
                    {
                        #if __INTEROPTOPUS_NEVER
                        #elif NETCOREAPP
                        Unsafe.CopyBlock(dst, data.ToPointer(), (uint) len * (uint) sizeof(byte));
                        #else
                        for (var i = 0; i < (int) len; i++) {
                            rval[i] = this[i];
                        }
                        #endif
                    }
                }
                return rval;
            }
        }
        public int Count => (int) len;
        public IEnumerator<byte> GetEnumerator()
        {
            for (var i = 0; i < (int)len; ++i)
            {
                yield return this[i];
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }


    ///Option type containing boolean flag and maybe valid data.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct OptionCatchDifficultyAttributes
    {
        ///Element that is maybe valid.
        CatchDifficultyAttributes t;
        ///Byte where `1` means element `t` is valid.
        byte is_some;
    }

    public partial struct OptionCatchDifficultyAttributes
    {
        public static OptionCatchDifficultyAttributes FromNullable(CatchDifficultyAttributes? nullable)
        {
            var result = new OptionCatchDifficultyAttributes();
            if (nullable.HasValue)
            {
                result.is_some = 1;
                result.t = nullable.Value;
            }

            return result;
        }

        public CatchDifficultyAttributes? ToNullable()
        {
            return this.is_some == 1 ? this.t : (CatchDifficultyAttributes?)null;
        }
    }


    ///Option type containing boolean flag and maybe valid data.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct OptionCatchPerformanceAttributes
    {
        ///Element that is maybe valid.
        CatchPerformanceAttributes t;
        ///Byte where `1` means element `t` is valid.
        byte is_some;
    }

    public partial struct OptionCatchPerformanceAttributes
    {
        public static OptionCatchPerformanceAttributes FromNullable(CatchPerformanceAttributes? nullable)
        {
            var result = new OptionCatchPerformanceAttributes();
            if (nullable.HasValue)
            {
                result.is_some = 1;
                result.t = nullable.Value;
            }

            return result;
        }

        public CatchPerformanceAttributes? ToNullable()
        {
            return this.is_some == 1 ? this.t : (CatchPerformanceAttributes?)null;
        }
    }


    ///Option type containing boolean flag and maybe valid data.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct OptionManiaDifficultyAttributes
    {
        ///Element that is maybe valid.
        ManiaDifficultyAttributes t;
        ///Byte where `1` means element `t` is valid.
        byte is_some;
    }

    public partial struct OptionManiaDifficultyAttributes
    {
        public static OptionManiaDifficultyAttributes FromNullable(ManiaDifficultyAttributes? nullable)
        {
            var result = new OptionManiaDifficultyAttributes();
            if (nullable.HasValue)
            {
                result.is_some = 1;
                result.t = nullable.Value;
            }

            return result;
        }

        public ManiaDifficultyAttributes? ToNullable()
        {
            return this.is_some == 1 ? this.t : (ManiaDifficultyAttributes?)null;
        }
    }


    ///Option type containing boolean flag and maybe valid data.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct OptionManiaPerformanceAttributes
    {
        ///Element that is maybe valid.
        ManiaPerformanceAttributes t;
        ///Byte where `1` means element `t` is valid.
        byte is_some;
    }

    public partial struct OptionManiaPerformanceAttributes
    {
        public static OptionManiaPerformanceAttributes FromNullable(ManiaPerformanceAttributes? nullable)
        {
            var result = new OptionManiaPerformanceAttributes();
            if (nullable.HasValue)
            {
                result.is_some = 1;
                result.t = nullable.Value;
            }

            return result;
        }

        public ManiaPerformanceAttributes? ToNullable()
        {
            return this.is_some == 1 ? this.t : (ManiaPerformanceAttributes?)null;
        }
    }


    ///Option type containing boolean flag and maybe valid data.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct OptionOsuDifficultyAttributes
    {
        ///Element that is maybe valid.
        OsuDifficultyAttributes t;
        ///Byte where `1` means element `t` is valid.
        byte is_some;
    }

    public partial struct OptionOsuDifficultyAttributes
    {
        public static OptionOsuDifficultyAttributes FromNullable(OsuDifficultyAttributes? nullable)
        {
            var result = new OptionOsuDifficultyAttributes();
            if (nullable.HasValue)
            {
                result.is_some = 1;
                result.t = nullable.Value;
            }

            return result;
        }

        public OsuDifficultyAttributes? ToNullable()
        {
            return this.is_some == 1 ? this.t : (OsuDifficultyAttributes?)null;
        }
    }


    ///Option type containing boolean flag and maybe valid data.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct OptionOsuPerformanceAttributes
    {
        ///Element that is maybe valid.
        OsuPerformanceAttributes t;
        ///Byte where `1` means element `t` is valid.
        byte is_some;
    }

    public partial struct OptionOsuPerformanceAttributes
    {
        public static OptionOsuPerformanceAttributes FromNullable(OsuPerformanceAttributes? nullable)
        {
            var result = new OptionOsuPerformanceAttributes();
            if (nullable.HasValue)
            {
                result.is_some = 1;
                result.t = nullable.Value;
            }

            return result;
        }

        public OsuPerformanceAttributes? ToNullable()
        {
            return this.is_some == 1 ? this.t : (OsuPerformanceAttributes?)null;
        }
    }


    ///Option type containing boolean flag and maybe valid data.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct OptionTaikoDifficultyAttributes
    {
        ///Element that is maybe valid.
        TaikoDifficultyAttributes t;
        ///Byte where `1` means element `t` is valid.
        byte is_some;
    }

    public partial struct OptionTaikoDifficultyAttributes
    {
        public static OptionTaikoDifficultyAttributes FromNullable(TaikoDifficultyAttributes? nullable)
        {
            var result = new OptionTaikoDifficultyAttributes();
            if (nullable.HasValue)
            {
                result.is_some = 1;
                result.t = nullable.Value;
            }

            return result;
        }

        public TaikoDifficultyAttributes? ToNullable()
        {
            return this.is_some == 1 ? this.t : (TaikoDifficultyAttributes?)null;
        }
    }


    ///Option type containing boolean flag and maybe valid data.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct OptionTaikoPerformanceAttributes
    {
        ///Element that is maybe valid.
        TaikoPerformanceAttributes t;
        ///Byte where `1` means element `t` is valid.
        byte is_some;
    }

    public partial struct OptionTaikoPerformanceAttributes
    {
        public static OptionTaikoPerformanceAttributes FromNullable(TaikoPerformanceAttributes? nullable)
        {
            var result = new OptionTaikoPerformanceAttributes();
            if (nullable.HasValue)
            {
                result.is_some = 1;
                result.t = nullable.Value;
            }

            return result;
        }

        public TaikoPerformanceAttributes? ToNullable()
        {
            return this.is_some == 1 ? this.t : (TaikoPerformanceAttributes?)null;
        }
    }


    ///Option type containing boolean flag and maybe valid data.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Optionf64
    {
        ///Element that is maybe valid.
        double t;
        ///Byte where `1` means element `t` is valid.
        byte is_some;
    }

    public partial struct Optionf64
    {
        public static Optionf64 FromNullable(double? nullable)
        {
            var result = new Optionf64();
            if (nullable.HasValue)
            {
                result.is_some = 1;
                result.t = nullable.Value;
            }

            return result;
        }

        public double? ToNullable()
        {
            return this.is_some == 1 ? this.t : (double?)null;
        }
    }


    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Bool
    {
        byte value;
    }

    public partial struct Bool
    {
        public static readonly Bool True = new Bool { value =  1 };
        public static readonly Bool False = new Bool { value =  0 };
        public Bool(bool b)
        {
            value = (byte) (b ? 1 : 0);
        }
        public bool Is => value == 1;
    }



    public partial class BeatmapAttributesBuilder : IDisposable
    {
        private IntPtr _context;

        private BeatmapAttributesBuilder() {}

        public static BeatmapAttributesBuilder New()
        {
            var self = new BeatmapAttributesBuilder();
            var rval = RosuLibrary.beatmap_attributes_new(ref self._context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = RosuLibrary.beatmap_attributes_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public void Mode(Mode mode)
        {
            RosuLibrary.beatmap_attributes_mode(_context, mode);
        }

        public void PMods(IntPtr mods)
        {
            RosuLibrary.beatmap_attributes_p_mods(_context, mods);
        }

        public void IMods(uint mods)
        {
            RosuLibrary.beatmap_attributes_i_mods(_context, mods);
        }

        public void SMods(string str)
        {
            var rval = RosuLibrary.beatmap_attributes_s_mods(_context, str);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public void ClockRate(double clock_rate)
        {
            RosuLibrary.beatmap_attributes_clock_rate(_context, clock_rate);
        }

        public void Ar(float ar)
        {
            RosuLibrary.beatmap_attributes_ar(_context, ar);
        }

        public void Cs(float cs)
        {
            RosuLibrary.beatmap_attributes_cs(_context, cs);
        }

        public void Hp(float hp)
        {
            RosuLibrary.beatmap_attributes_hp(_context, hp);
        }

        public void Od(float od)
        {
            RosuLibrary.beatmap_attributes_od(_context, od);
        }

        public double GetClockRate()
        {
            return RosuLibrary.beatmap_attributes_get_clock_rate(_context);
        }

        public BeatmapAttributes Build(IntPtr beatmap)
        {
            return RosuLibrary.beatmap_attributes_build(_context, beatmap);
        }

        public IntPtr Context => _context;
    }


    public partial class Beatmap : IDisposable
    {
        private IntPtr _context;

        private Beatmap() {}

        public static Beatmap FromBytes(Sliceu8 data)
        {
            var self = new Beatmap();
            var rval = RosuLibrary.beatmap_from_bytes(ref self._context, data);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static Beatmap FromPath(string path)
        {
            var self = new Beatmap();
            var rval = RosuLibrary.beatmap_from_path(ref self._context, path);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = RosuLibrary.beatmap_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        /// Convert a Beatmap to the specified mode
        public Bool Convert(Mode mode, IntPtr mods)
        {
            return RosuLibrary.beatmap_convert(_context, mode, mods);
        }

        public double Bpm()
        {
            return RosuLibrary.beatmap_bpm(_context);
        }

        public double TotalBreakTime()
        {
            return RosuLibrary.beatmap_total_break_time(_context);
        }

        public Mode Mode()
        {
            return RosuLibrary.beatmap_mode(_context);
        }

        public Bool IsConvert()
        {
            return RosuLibrary.beatmap_is_convert(_context);
        }

        public IntPtr Context => _context;
    }


    public partial class Difficulty : IDisposable
    {
        private IntPtr _context;

        private Difficulty() {}

        public static Difficulty New()
        {
            var self = new Difficulty();
            var rval = RosuLibrary.difficulty_new(ref self._context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = RosuLibrary.difficulty_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public void PMods(IntPtr mods)
        {
            RosuLibrary.difficulty_p_mods(_context, mods);
        }

        public void IMods(uint mods)
        {
            RosuLibrary.difficulty_i_mods(_context, mods);
        }

        public void SMods(string str)
        {
            var rval = RosuLibrary.difficulty_s_mods(_context, str);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public void PassedObjects(uint passed_objects)
        {
            RosuLibrary.difficulty_passed_objects(_context, passed_objects);
        }

        public void ClockRate(double clock_rate)
        {
            RosuLibrary.difficulty_clock_rate(_context, clock_rate);
        }

        public void Ar(float ar)
        {
            RosuLibrary.difficulty_ar(_context, ar);
        }

        public void Cs(float cs)
        {
            RosuLibrary.difficulty_cs(_context, cs);
        }

        public void Hp(float hp)
        {
            RosuLibrary.difficulty_hp(_context, hp);
        }

        public void Od(float od)
        {
            RosuLibrary.difficulty_od(_context, od);
        }

        public void HardrockOffsets(Bool hardrock_offsets)
        {
            RosuLibrary.difficulty_hardrock_offsets(_context, hardrock_offsets);
        }

        public void Lazer(Bool lazer)
        {
            RosuLibrary.difficulty_lazer(_context, lazer);
        }

        public DifficultyAttributes Calculate(IntPtr beatmap)
        {
            return RosuLibrary.difficulty_calculate(_context, beatmap);
        }

        public double GetClockRate()
        {
            return RosuLibrary.difficulty_get_clock_rate(_context);
        }

        public IntPtr Context => _context;
    }


    public partial class Performance : IDisposable
    {
        private IntPtr _context;

        private Performance() {}

        public static Performance New()
        {
            var self = new Performance();
            var rval = RosuLibrary.performance_new(ref self._context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = RosuLibrary.performance_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public void Mode(Mode mode)
        {
            RosuLibrary.performance_mode(_context, mode);
        }

        public void PMods(IntPtr mods)
        {
            RosuLibrary.performance_p_mods(_context, mods);
        }

        public void IMods(uint mods)
        {
            RosuLibrary.performance_i_mods(_context, mods);
        }

        public void SMods(string str)
        {
            var rval = RosuLibrary.performance_s_mods(_context, str);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public void PassedObjects(uint passed_objects)
        {
            RosuLibrary.performance_passed_objects(_context, passed_objects);
        }

        public void ClockRate(double clock_rate)
        {
            RosuLibrary.performance_clock_rate(_context, clock_rate);
        }

        public void Ar(float ar)
        {
            RosuLibrary.performance_ar(_context, ar);
        }

        public void Cs(float cs)
        {
            RosuLibrary.performance_cs(_context, cs);
        }

        public void Hp(float hp)
        {
            RosuLibrary.performance_hp(_context, hp);
        }

        public void Od(float od)
        {
            RosuLibrary.performance_od(_context, od);
        }

        public void HardrockOffsets(Bool hardrock_offsets)
        {
            RosuLibrary.performance_hardrock_offsets(_context, hardrock_offsets);
        }

        public void State(ScoreState state)
        {
            RosuLibrary.performance_state(_context, state);
        }

        public void Accuracy(double accuracy)
        {
            RosuLibrary.performance_accuracy(_context, accuracy);
        }

        public void Misses(uint misses)
        {
            RosuLibrary.performance_misses(_context, misses);
        }

        public void Combo(uint combo)
        {
            RosuLibrary.performance_combo(_context, combo);
        }

        public void HitresultPriority(HitResultPriority hitresult_priority)
        {
            RosuLibrary.performance_hitresult_priority(_context, hitresult_priority);
        }

        public void Lazer(Bool lazer)
        {
            RosuLibrary.performance_lazer(_context, lazer);
        }

        public void LargeTickHits(uint large_tick_hits)
        {
            RosuLibrary.performance_large_tick_hits(_context, large_tick_hits);
        }

        public void SmallTickHits(uint small_tick_hits)
        {
            RosuLibrary.performance_small_tick_hits(_context, small_tick_hits);
        }

        public void SliderEndHits(uint slider_end_hits)
        {
            RosuLibrary.performance_slider_end_hits(_context, slider_end_hits);
        }

        public void N300(uint n300)
        {
            RosuLibrary.performance_n300(_context, n300);
        }

        public void N100(uint n100)
        {
            RosuLibrary.performance_n100(_context, n100);
        }

        public void N50(uint n50)
        {
            RosuLibrary.performance_n50(_context, n50);
        }

        public void NKatu(uint n_katu)
        {
            RosuLibrary.performance_n_katu(_context, n_katu);
        }

        public void NGeki(uint n_geki)
        {
            RosuLibrary.performance_n_geki(_context, n_geki);
        }

        public ScoreState GenerateState(IntPtr beatmap)
        {
            return RosuLibrary.performance_generate_state(_context, beatmap);
        }

        public ScoreState GenerateStateFromDifficulty(DifficultyAttributes difficulty_attr)
        {
            return RosuLibrary.performance_generate_state_from_difficulty(_context, difficulty_attr);
        }

        public PerformanceAttributes Calculate(IntPtr beatmap)
        {
            return RosuLibrary.performance_calculate(_context, beatmap);
        }

        public PerformanceAttributes CalculateFromDifficulty(DifficultyAttributes difficulty_attr)
        {
            return RosuLibrary.performance_calculate_from_difficulty(_context, difficulty_attr);
        }

        public double GetClockRate()
        {
            return RosuLibrary.performance_get_clock_rate(_context);
        }

        public IntPtr Context => _context;
    }


    public partial class OwnedString : IDisposable
    {
        private IntPtr _context;

        private OwnedString() {}

        public static OwnedString FromCStr(string str)
        {
            var self = new OwnedString();
            var rval = RosuLibrary.string_from_c_str(ref self._context, str);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static OwnedString Empty()
        {
            var self = new OwnedString();
            var rval = RosuLibrary.string_empty(ref self._context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = RosuLibrary.string_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public Bool IsInit()
        {
            return RosuLibrary.string_is_init(_context);
        }

        public string ToCstr()
        {
            var s = RosuLibrary.string_to_cstr(_context);
            return Marshal.PtrToStringAnsi(s);
        }

        public IntPtr Context => _context;
    }


    public partial class Mods : IDisposable
    {
        private IntPtr _context;

        private Mods() {}

        public static Mods New(Mode mode)
        {
            var self = new Mods();
            var rval = RosuLibrary.mods_new(ref self._context, mode);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static Mods FromAcronyms(string str, Mode mode)
        {
            var self = new Mods();
            var rval = RosuLibrary.mods_from_acronyms(ref self._context, str, mode);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static Mods FromBits(uint bits, Mode mode)
        {
            var self = new Mods();
            var rval = RosuLibrary.mods_from_bits(ref self._context, bits, mode);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static Mods FromJson(string str, Mode mode)
        {
            var self = new Mods();
            var rval = RosuLibrary.mods_from_json(ref self._context, str, mode);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static Mods FromJsonSanitize(string str, Mode mode)
        {
            var self = new Mods();
            var rval = RosuLibrary.mods_from_json_sanitize(ref self._context, str, mode);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = RosuLibrary.mods_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public void RemoveIncompatibleMods()
        {
            RosuLibrary.mods_remove_incompatible_mods(_context);
        }

        public uint Bits()
        {
            return RosuLibrary.mods_bits(_context);
        }

        public uint Len()
        {
            return RosuLibrary.mods_len(_context);
        }

        public void Json(IntPtr str)
        {
            RosuLibrary.mods_json(_context, str);
        }

        public Bool InsertJson(string str)
        {
            return RosuLibrary.mods_insert_json(_context, str);
        }

        public Bool Insert(string str)
        {
            return RosuLibrary.mods_insert(_context, str);
        }

        public Bool Contains(string str)
        {
            return RosuLibrary.mods_contains(_context, str);
        }

        public void Clear()
        {
            RosuLibrary.mods_clear(_context);
        }

        public Optionf64 ClockRate()
        {
            return RosuLibrary.mods_clock_rate(_context);
        }

        public IntPtr Context => _context;
    }



    public class InteropException<T> : Exception
    {
        public T Error { get; private set; }

        public InteropException(T error): base($"Something went wrong: {error}")
        {
            Error = error;
        }
    }

}
